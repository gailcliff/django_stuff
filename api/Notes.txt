STARTING A NEW DJANGO PROJECT
(PyCharm handles this first step for you automatically once you create a new Django project)

cd into directory and enter command: django-admin startproject mysite ('mysite' is the project name)
Avoid naming projects after built-in Python or Django components.

It’s not a good idea to put any of your Python project code within your web server’s document root (esp. in prod) like you do in PHP, because it risks
the possibility that people may be able to view your code over the web. That’s not good for security.
Put your code in some directory OUTSIDE of the document root, such as /home/mycode.

Project Structure
mysite/  # This is the top level-directory. The name of the directory doesn't matter (can name it whatever)
    manage.py
    mysite/ # This inner directory is the actual Python package for your project
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py

***Don’t use Django's development server in anything resembling a production environment. It’s intended only for use while developing.***

To get your project running on the web server, type command: python manage.py runserver port_no(e.g 8000)

CREATING A NEW APP
Apps live in the top-level directory (preferably), same level as your django project and manage.py
Type this command to start a new app: python manage.py startapp app_name


SIMPLE VIEW
from django.http import HttpResponse

def home(request):  # each view is passed in a HttpRequest object ('request' in this case) as the first argument
    return HttpResponse('Welcome home to the polls!')  # HttpResponse is used to send the result back to the client

After the above you need to create a urls.py file in your app directory (if you haven't).
That's where you'll write url configurations for your app (in the urlpatterns list)

--urls.py--
from django import urls  # alternatively: from django.urls import path

urlpatterns = [
    urls.path('', views.home, name='home')  # first parameter is the route string,
                                            # second parameter is the view to direct to,
                                            # third parameter (with keyword 'name', is the name of this url configuration
    # Naming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates. This powerful feature allows you to make global
    # changes to the URL patterns of your project while only touching a single file
]

Now go to your central project's urls.py file and plug your urls.py configuration file there
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),  # this will redirect to the django admin console
    path('home/', urls.include('polls.urls'))  # using include will redirect to your app's url configuration file, and then your app will handle redirecting
                                               # to the appropriate views
                                               # the string in include is 'app_name.path.to.url_conf_file' (uses . to provide path to url conf file)
]


DATABASES
In the settings.py file in your project dir, find the DATABASES dictionary

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # will be .mysql, .postgresql, .oracle depending on the db you're using
        'NAME': BASE_DIR / 'db.sqlite3',
        # if using mysql, postgres etc, you have to add USER, HOST AND PASSWORD
    }
}

Time Zone Setting
It is recommended to use UTC in your database records because UTC (Universal Coordinated Time) is standard, not affected by things like DST

In your settings.py file, modify these:
TIME_ZONE = 'UTC'  # you can put whatever timezone, e.g Africa/Nairobi or America/New_York

USE_TZ = True  # whether or not to use timezone


The INSTALLED_APPS list in settings.py
One of its purposes is for database migrations, when you run the command: python manage.py migrate
The migrate command looks at the INSTALLED_APPS setting and creates any necessary database tables according to the database settings in your
mysite/settings.py  file and the database migrations shipped with the app.

You should add your app to INSTALLED_APPS for database migrations. We need to tell our project that a specific app is installed.

Philosophy
Django apps are “pluggable”: You can use an app in multiple projects, and you can distribute apps, because they don’t have to be tied to a given Django installation.

To install/register your app in INSTALLED_APPS, you'll need the {extends AppConfig} class in your apps.py file. It will named be your
AppNameConfig.
Go to INSTALLED_APPS and add this to the list: 'app_name.apps.AppNameConfig'

After the above you can then run migrations and your app's models will be created/updated in the database.


GETTING YOUR MODELS FROM models.py TO THE DATABASE
1. Write your models (inheriting from django.db.models.Model) in models.py file
2. Make sure your app is installed (see above). If app is not installed migrations can't be made!
3. Run 'python manage.py makemigrations' on cmd
4. Might be good to check the SQL that will be executed.
    Run 'python manage.py sqlmigrate app_name migration_name', e.g python manage.py sqlmigrate polls 0001_initial
        - polls is the name of your app
        - 0001_initial is the name of the migration python file that was generated when you ran makemigrations
    sqlmigrate doesn't migrate your models, only returns the sql that would be executed.
5. Run 'python manage.py migrate' to migrate all your changes to the db
    Migrations are very powerful and let you change your models over time, as you develop your project, without
    the need to delete your database or tables and make new ones - it specializes in upgrading your database live,
    without losing data.

    The reason that there are separate commands to make and apply migrations is because you’ll commit migrations to your version control system and ship them
    with your app; they not only make your development easier, they’re also usable by other developers and in production.
    Also, each version of your app will have the migrations files present with the schema of your database, so that you can roll back your database, check
    previous versions of your database, and even debug, etc easily!
6. IDK, but also running 'python manage.py check' to check issues with your project without touching the db/migrations can be a good thing.


HANDLING TIMEZONES

- Getting current datetime:

from django.utils import timezone
now = timezone.now()

- Getting time in the future or past by adding or subtracting a delta
Use the delta function: django.utils.timezone.timedelta or datetime.timedelta (this one is from python builtins)

print(f"Today's date and time is: {now} <br>"
f"7 days ago it was:  {now - timezone.timedelta(days=7)} <br>" # returns the datetime 7 days ago
f"7 days from now it will be:  {now + timezone.timedelta(days=7)}") # returns datetime 7 days from now

Can pass in days, weeks, hours, seconds etc
Method signature:
def __new__(cls, days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)


CREATING DJANGO ADMIN SUPERUSER
Use command: python manage.py createsuperuser. Will ask for username and password (thegailcliff 12345 gail@cliff.com)
3

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